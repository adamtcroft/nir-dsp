// (C) 2026 and later NIR, LLC
// All Rights Reserved
// Author: Adam T. Croft

desc: Low Pass Filter Graph Prototype (NIR)

import library.jsfx-inc

// Sliders
slider1:cutoffFreq=632<20,20000,1:log=632>Cutoff Frequency (Hz)
slider2:qSlider=0.707<0.1,10,0.01:log=1>Resonance (Q)
slider3:slopeSelector=0<0,3,1{-12 dB/oct,-24 dB/oct,-36 dB/oct,-48 dB/oct}>Slope

// Multi-channel support: allow automatic channel detection
in_pin:none
out_pin:none

@init
// Initialize biquad filters for up to 8 channels (7.1 surround)
// Each channel needs up to 4 stages for -48dB/oct
// Channels: 0=FL, 1=FR, 2=C, 3=LFE, 4=BL, 5=BR, 6=SL, 7=SR

// Channel 0 (Front Left)
filter0_1.biquad_init();
filter0_2.biquad_init();
filter0_3.biquad_init();
filter0_4.biquad_init();

// Channel 1 (Front Right)
filter1_1.biquad_init();
filter1_2.biquad_init();
filter1_3.biquad_init();
filter1_4.biquad_init();

// Channel 2 (Center)
filter2_1.biquad_init();
filter2_2.biquad_init();
filter2_3.biquad_init();
filter2_4.biquad_init();

// Channel 3 (LFE)
filter3_1.biquad_init();
filter3_2.biquad_init();
filter3_3.biquad_init();
filter3_4.biquad_init();

// Channel 4 (Back Left)
filter4_1.biquad_init();
filter4_2.biquad_init();
filter4_3.biquad_init();
filter4_4.biquad_init();

// Channel 5 (Back Right)
filter5_1.biquad_init();
filter5_2.biquad_init();
filter5_3.biquad_init();
filter5_4.biquad_init();

// Channel 6 (Side Left)
filter6_1.biquad_init();
filter6_2.biquad_init();
filter6_3.biquad_init();
filter6_4.biquad_init();

// Channel 7 (Side Right)
filter7_1.biquad_init();
filter7_2.biquad_init();
filter7_3.biquad_init();
filter7_4.biquad_init();

// Helper function to update all coefficients for a channel
function updateChannelCoeffs(ch, freq, q, sr)
(
	ch == 0 ? (
		filter0_1.biquad_setLowPass(freq, q, sr);
		filter0_2.biquad_setLowPass(freq, q, sr);
		filter0_3.biquad_setLowPass(freq, q, sr);
		filter0_4.biquad_setLowPass(freq, q, sr);
	) : ch == 1 ? (
		filter1_1.biquad_setLowPass(freq, q, sr);
		filter1_2.biquad_setLowPass(freq, q, sr);
		filter1_3.biquad_setLowPass(freq, q, sr);
		filter1_4.biquad_setLowPass(freq, q, sr);
	) : ch == 2 ? (
		filter2_1.biquad_setLowPass(freq, q, sr);
		filter2_2.biquad_setLowPass(freq, q, sr);
		filter2_3.biquad_setLowPass(freq, q, sr);
		filter2_4.biquad_setLowPass(freq, q, sr);
	) : ch == 3 ? (
		filter3_1.biquad_setLowPass(freq, q, sr);
		filter3_2.biquad_setLowPass(freq, q, sr);
		filter3_3.biquad_setLowPass(freq, q, sr);
		filter3_4.biquad_setLowPass(freq, q, sr);
	) : ch == 4 ? (
		filter4_1.biquad_setLowPass(freq, q, sr);
		filter4_2.biquad_setLowPass(freq, q, sr);
		filter4_3.biquad_setLowPass(freq, q, sr);
		filter4_4.biquad_setLowPass(freq, q, sr);
	) : ch == 5 ? (
		filter5_1.biquad_setLowPass(freq, q, sr);
		filter5_2.biquad_setLowPass(freq, q, sr);
		filter5_3.biquad_setLowPass(freq, q, sr);
		filter5_4.biquad_setLowPass(freq, q, sr);
	) : ch == 6 ? (
		filter6_1.biquad_setLowPass(freq, q, sr);
		filter6_2.biquad_setLowPass(freq, q, sr);
		filter6_3.biquad_setLowPass(freq, q, sr);
		filter6_4.biquad_setLowPass(freq, q, sr);
	) : ch == 7 ? (
		filter7_1.biquad_setLowPass(freq, q, sr);
		filter7_2.biquad_setLowPass(freq, q, sr);
		filter7_3.biquad_setLowPass(freq, q, sr);
		filter7_4.biquad_setLowPass(freq, q, sr);
	);
);

function freqToGraphX(freq, left, width)
local(logFreq, normLog, norm)
(
	logFreq = log(max(20, min(20000, freq)));
	normLog = (logFreq - log(20)) / (log(20000) - log(20));
	// Piecewise warp: give extra horizontal space to lows, less to highs.
	normLog < 0.3333333333333333 ? (
		norm = (normLog / 0.3333333333333333) * 0.40;
	) : normLog < 0.6666666666666666 ? (
		norm = 0.40 + ((normLog - 0.3333333333333333) / 0.3333333333333333) * 0.35;
	) : (
		norm = 0.75 + ((normLog - 0.6666666666666666) / 0.3333333333333333) * 0.25;
	);
	left + norm * width;
);

function graphNormToFreq(norm)
local(normLog)
(
	norm < 0 ? norm = 0;
	norm > 1 ? norm = 1;
	norm < 0.40 ? (
		normLog = (norm / 0.40) * 0.3333333333333333;
	) : norm < 0.75 ? (
		normLog = 0.3333333333333333 + ((norm - 0.40) / 0.35) * 0.3333333333333333;
	) : (
		normLog = 0.6666666666666666 + ((norm - 0.75) / 0.25) * 0.3333333333333333;
	);
	20 * pow(1000, normLog);
);

function dbToGraphY(db, top, height)
local(clamped)
(
	clamped = max(-72, min(12, db));
	top + ((12 - clamped) / 84) * height;
);

function analyzerDbToGraphY(db, top, height)
local(clamped)
(
	clamped = max(-96, min(12, db));
	top + ((12 - clamped) / 108) * height;
);

function biquadMagAtFreq(freq, stages)
local(w, z1r, z1i, z2r, z2i, numr, numi, denr, deni, numMag, denMag, mag)
(
	w = 2 * $pi * freq / srate;
	z1r = cos(w);
	z1i = -sin(w);
	z2r = cos(2 * w);
	z2i = -sin(2 * w);

	numr = filter0_1.b0 + filter0_1.b1 * z1r + filter0_1.b2 * z2r;
	numi = filter0_1.b1 * z1i + filter0_1.b2 * z2i;

	denr = 1 + filter0_1.a1 * z1r + filter0_1.a2 * z2r;
	deni = filter0_1.a1 * z1i + filter0_1.a2 * z2i;

	numMag = sqrt(numr * numr + numi * numi);
		denMag = sqrt(denr * denr + deni * deni);
		denMag = max(denMag, 0.00000000000000000001);
	mag = numMag / denMag;
	stages > 1 ? mag = pow(mag, stages);
	mag;
);

// Initialize coefficients for all channels
i = 0;
while (i < 8) (
	updateChannelCoeffs(i, cutoffFreq, qSlider, srate);
	i += 1;
);

// Real-time analyzer state tuned for smoother UI frame-time behavior
FFT_SIZE = 4096;
FFT_HOP = 1024;
AN_ATTACK = 0.50;
AN_RELEASE = 0.14;
AN_FLOOR_DB = -96;
AN_CEIL_DB = 12;
ringBase = 131072;
windowBase = ringBase + FFT_SIZE;
fftBase = windowBase + FFT_SIZE;
specBase = fftBase + FFT_SIZE * 2;
specBins = FFT_SIZE / 2 + 1;
analyzerMaxBin = specBins - 1;
anWritePos = 0;
anFill = 0;
anHopCounter = 0;
analyzerReady = 0;
i = 0;
while (i < FFT_SIZE) (
	windowBase[i] = 0.5 - 0.5 * cos((2 * $pi * i) / (FFT_SIZE - 1));
	i += 1;
);
i = 0;
while (i < specBins) (
	specBase[i] = AN_FLOOR_DB;
	i += 1;
);

@slider
// Update filter coefficients for all channels when sliders change
i = 0;
while (i < 8) (
	updateChannelCoeffs(i, cutoffFreq, qSlider, srate);
	i += 1;
);

@block
halfBins = FFT_SIZE / 2;
analyzerMaxBin = min(halfBins, floor((20000 * FFT_SIZE) / srate) + 1);
anHopCounter >= FFT_HOP && anFill >= FFT_SIZE ? (
	anHopCounter -= FFT_HOP;

	// Gather latest FFT_SIZE processed samples from circular buffer and apply Hann window.
	i = 0;
	framePeak = 0;
	while (i < FFT_SIZE) (
		srcPos = anWritePos + i;
		srcPos >= FFT_SIZE ? srcPos -= FFT_SIZE;
		frameSample = ringBase[srcPos] * windowBase[i];
		framePeak = max(framePeak, abs(frameSample));
		fftBase[2 * i] = frameSample;
		fftBase[2 * i + 1] = 0;
		i += 1;
	);

		framePeak < 0.0000005 ? (
			// With effectively silent input, decay bins smoothly to floor to avoid idle spikes.
			i = 0;
			while (i <= analyzerMaxBin) (
				prevDb = specBase[i];
				specBase[i] = prevDb + (AN_FLOOR_DB - prevDb) * AN_RELEASE;
				i += 1;
			);
		) : (
		fft(fftBase, FFT_SIZE);
			fft_permute(fftBase, FFT_SIZE);

			i = 0;
			while (i <= analyzerMaxBin) (
				re = fftBase[2 * i];
				im = fftBase[2 * i + 1];
				mag = sqrt(re * re + im * im);
			db = 20 * log10(max(mag, 0.000000000001));
			db -= 20 * log10(FFT_SIZE * 0.5);
			db = max(AN_FLOOR_DB, min(AN_CEIL_DB, db));

			prevDb = specBase[i];
			db > prevDb ? (
				specBase[i] = prevDb + (db - prevDb) * AN_ATTACK;
			) : (
				specBase[i] = prevDb + (db - prevDb) * AN_RELEASE;
			);
			i += 1;
		);
	);

	analyzerReady = 1;

	// Drop excess backlog to avoid multi-FFT burst work that can glitch the GUI.
	anHopCounter >= FFT_HOP ? anHopCounter = FFT_HOP - 1;
);

@sample
// Process only active channels (detected via num_ch)
// slopeSelector: 0=-12dB/oct (1 stage), 1=-24dB/oct (2 stages), 2=-36dB/oct (3 stages), 3=-48dB/oct (4 stages)

// Channel 0
num_ch >= 1 ? (
	spl0 = filter0_1.biquad_process(spl0);
	slopeSelector >= 1 ? spl0 = filter0_2.biquad_process(spl0);
	slopeSelector >= 2 ? spl0 = filter0_3.biquad_process(spl0);
	slopeSelector >= 3 ? spl0 = filter0_4.biquad_process(spl0);
);

// Channel 1
num_ch >= 2 ? (
	spl1 = filter1_1.biquad_process(spl1);
	slopeSelector >= 1 ? spl1 = filter1_2.biquad_process(spl1);
	slopeSelector >= 2 ? spl1 = filter1_3.biquad_process(spl1);
	slopeSelector >= 3 ? spl1 = filter1_4.biquad_process(spl1);
);

// Channel 2
num_ch >= 3 ? (
	spl2 = filter2_1.biquad_process(spl2);
	slopeSelector >= 1 ? spl2 = filter2_2.biquad_process(spl2);
	slopeSelector >= 2 ? spl2 = filter2_3.biquad_process(spl2);
	slopeSelector >= 3 ? spl2 = filter2_4.biquad_process(spl2);
);

// Channel 3 (LFE)
num_ch >= 4 ? (
	spl3 = filter3_1.biquad_process(spl3);
	slopeSelector >= 1 ? spl3 = filter3_2.biquad_process(spl3);
	slopeSelector >= 2 ? spl3 = filter3_3.biquad_process(spl3);
	slopeSelector >= 3 ? spl3 = filter3_4.biquad_process(spl3);
);

// Channel 4
num_ch >= 5 ? (
	spl4 = filter4_1.biquad_process(spl4);
	slopeSelector >= 1 ? spl4 = filter4_2.biquad_process(spl4);
	slopeSelector >= 2 ? spl4 = filter4_3.biquad_process(spl4);
	slopeSelector >= 3 ? spl4 = filter4_4.biquad_process(spl4);
);

// Channel 5
num_ch >= 6 ? (
	spl5 = filter5_1.biquad_process(spl5);
	slopeSelector >= 1 ? spl5 = filter5_2.biquad_process(spl5);
	slopeSelector >= 2 ? spl5 = filter5_3.biquad_process(spl5);
	slopeSelector >= 3 ? spl5 = filter5_4.biquad_process(spl5);
);

// Channel 6
num_ch >= 7 ? (
	spl6 = filter6_1.biquad_process(spl6);
	slopeSelector >= 1 ? spl6 = filter6_2.biquad_process(spl6);
	slopeSelector >= 2 ? spl6 = filter6_3.biquad_process(spl6);
	slopeSelector >= 3 ? spl6 = filter6_4.biquad_process(spl6);
);

// Channel 7
num_ch >= 8 ? (
	spl7 = filter7_1.biquad_process(spl7);
	slopeSelector >= 1 ? spl7 = filter7_2.biquad_process(spl7);
	slopeSelector >= 2 ? spl7 = filter7_3.biquad_process(spl7);
	slopeSelector >= 3 ? spl7 = filter7_4.biquad_process(spl7);
);

// Feed analyzer from processed signal so trace reflects audible output spectrum.
analysisSample = spl0;
num_ch >= 2 ? analysisSample = 0.5 * (spl0 + spl1);
abs(analysisSample) < 0.000000000001 ? analysisSample = 0;
ringBase[anWritePos] = analysisSample;
anWritePos += 1;
anWritePos >= FFT_SIZE ? anWritePos = 0;
anFill < FFT_SIZE ? anFill += 1;
anHopCounter += 1;

@gfx 760 420
left = 56;
right = 18;
top = 22;
bottom = 34;
graphW = gfx_w - left - right;
graphH = gfx_h - top - bottom;

gfx_set(0.07, 0.09, 0.12, 1);
gfx_rect(0, 0, gfx_w, gfx_h, 1);

gfx_set(0.12, 0.15, 0.19, 1);
gfx_rect(left, top, graphW, graphH, 1);

idx = 0;
while (idx < 10) (
	idx == 0 ? freq = 20 :
	idx == 1 ? freq = 50 :
	idx == 2 ? freq = 100 :
	idx == 3 ? freq = 200 :
	idx == 4 ? freq = 500 :
	idx == 5 ? freq = 1000 :
	idx == 6 ? freq = 2000 :
	idx == 7 ? freq = 5000 :
	idx == 8 ? freq = 10000 :
	freq = 20000;

	x = freqToGraphX(freq, left, graphW);
	gfx_set(0.25, 0.30, 0.37, 0.65);
	gfx_line(x, top, x, top + graphH);

	gfx_set(0.66, 0.72, 0.80, 0.92);
	gfx_x = x + 2;
	gfx_y = top + graphH + 4;
	freq >= 1000 ? sprintf(#freqLabel, "%dk", freq / 1000) : sprintf(#freqLabel, "%d", freq);
	gfx_drawstr(#freqLabel);
	idx += 1;
);

idx = 0;
while (idx < 10) (
	idx == 0 ? db = 12 :
	idx == 1 ? db = 6 :
	idx == 2 ? db = 0 :
	idx == 3 ? db = -6 :
	idx == 4 ? db = -12 :
	idx == 5 ? db = -24 :
	idx == 6 ? db = -36 :
	idx == 7 ? db = -48 :
	idx == 8 ? db = -60 :
	db = -72;

	y = dbToGraphY(db, top, graphH);
	gfx_set(0.25, 0.30, 0.37, 0.65);
	gfx_line(left, y, left + graphW, y);

	gfx_set(0.66, 0.72, 0.80, 0.92);
	gfx_x = 7;
	gfx_y = y - 7;
	sprintf(#dbLabel, "%d", db);
	gfx_drawstr(#dbLabel);
	idx += 1;
);

gfx_set(0.18, 0.24, 0.30, 1);
gfx_rect(left, top, graphW, graphH, 0);

cutoffX = freqToGraphX(cutoffFreq, left, graphW);
gfx_set(0.96, 0.74, 0.24, 0.95);
gfx_line(cutoffX, top, cutoffX, top + graphH);

stages = floor(slopeSelector) + 1;
points = max(128, floor(graphW));
i = 0;
while (i < points) (
	normX = i / (points - 1);
	freq = graphNormToFreq(normX);
	mag = max(0.000000000001, biquadMagAtFreq(freq, stages));
	db = 20 * log10(mag);

	x = left + normX * graphW;
	y = dbToGraphY(db, top, graphH);

	i == 0 ? (
		gfx_x = x;
		gfx_y = y;
	) : (
		gfx_set(0.20, 0.85, 0.97, 0.98);
		gfx_lineto(x, y, 1);
	);
	i += 1;
);

cutoffMag = max(0.000000000001, biquadMagAtFreq(cutoffFreq, stages));
cutoffDb = 20 * log10(cutoffMag);
cutoffY = dbToGraphY(cutoffDb, top, graphH);

// Cutoff handle for clearer, EQ-style focus around the active frequency point.
gfx_set(0.96, 0.74, 0.24, 0.16);
gfx_circle(cutoffX, cutoffY, 9, 1, 1);
gfx_set(0.96, 0.74, 0.24, 0.95);
gfx_circle(cutoffX, cutoffY, 4, 0, 1);
gfx_set(0.07, 0.09, 0.12, 1);
gfx_circle(cutoffX, cutoffY, 2, 1, 1);

analyzerReady ? (
	halfBins = analyzerMaxBin;
	points = max(96, floor(graphW / 3));
	i = 0;
	while (i < points) (
		normX = i / (points - 1);
		freq = graphNormToFreq(normX);
		binPos = freq * FFT_SIZE / srate;
		binPos = max(0, min(halfBins - 1, binPos));
		binIdx = floor(binPos);
		binFrac = binPos - binIdx;
		dbA = specBase[binIdx];
		dbB = specBase[min(halfBins, binIdx + 1)];
		db = dbA + (dbB - dbA) * binFrac;

		x = left + normX * graphW;
		y = analyzerDbToGraphY(db, top, graphH);

		i == 0 ? (
			gfx_x = x;
			gfx_y = y;
		) : (
			gfx_set(0.98, 0.86, 0.28, 0.72);
			gfx_lineto(x, y, 1);
		);
		i += 1;
	);
);

gfx_set(0.88, 0.92, 0.98, 0.95);
gfx_x = left;
gfx_y = 2;
sprintf(#titleLabel, "Low-pass response  |  Cutoff %.0f Hz  |  Q %.2f  |  Slope %d dB/oct", cutoffFreq, qSlider, -12 * stages);
gfx_drawstr(#titleLabel);
